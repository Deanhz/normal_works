# -*- coding: utf-8 -*-
"""
Created on Tue Jul 17 19:46:53 2018

@author: Dean
多重背包问题
多重背包介于0-1背包和完全背包之间，物品有一定数量的限制k
先分组(1,2,4,8,16,...,2^c,剩余部分)，再转化为0-1背包问题。
处理该问题，见有道笔记。


为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾
区，现在假设你一共有资金 n 元，而市场有 m 种大米，每种大米都是袋装产品，
其价格不等，并且只能整袋购买。请问：你用有限的资金最多能采购多少公斤粮
食呢？
输入：
输入数据首先包含一个正整数 C，表示有 C 组测试用例，每组测试用例的第
一行是两个整数 n 和 m(1<=n<=100, 1<=m<=100),分别表示经费的金额和大米的
种 类 ， 然 后 是 m 行 数 据 ， 每 行 包 含 3 个 数 p ， h 和
c(1<=p<=20,1<=h<=200,1<=c<=20)，分别表示每袋的价格、每袋的重量以及对应
种类大米的袋数。
输出：
对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不
光所有的大米，并且经费你可以不用完。每个实例的输出占一行。
样例输入：
1
8 2
2 100 4
4 100 2
样例输出：
400
"""

def maxDP(n,m,arr):#n总资产，m物品种数
    cnt = 0 #拆分后的物品总数
    arr2 = []
    #对每个物品进行拆分
    for i in range(m):
        v,w,k = arr[i] #价格，重量，数量
        c = 1 # 保存新划分的每一部分数量
        while(k - c > 0):
            k -= c
            arr2.append([c*v, c*w])
            c = c*2 
            cnt += 1
        #剩余部分
        arr2.append([k*v, k*w])
    #划分完毕后，使用划分后的结果，进行0-1背包
    dp = [0 for j in range(n+1)]
    for j in range(n+1):
        dp[j] = arr2[0][1] if arr2[0][0] <= j else 0
    
    for i in range(len(arr2)):
        for j in range(arr2[i][0], n+1)[::-1]:
            dp[j] = max(dp[j],dp[j-arr2[i][0]]+arr2[i][1])
    return dp[n]
            
if __name__ == "__main__":
    print(maxDP(8,2,[[2,100,4],[4,100,2]]))
    
    
    
    
    
    
    
    
    
    
    
    
    
    